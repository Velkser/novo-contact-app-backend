import base64
import io
import json
import wave
import logging
import os
from datetime import datetime
from urllib.parse import quote, unquote
from typing import List, Optional, Dict, Any
import httpx

from twilio.twiml.voice_response import VoiceResponse, Gather


from fastapi import APIRouter, Depends, HTTPException, Query, Request, Response
from fastapi.responses import JSONResponse, StreamingResponse, FileResponse
from fastapi.websockets import WebSocket
from sqlalchemy.orm import Session

from app.database import get_db
from app.api import deps
from app.models.user import User
from app.models.contact import Contact, ContactDialog, DialogMessage
from app.services.twilio_service import twilio_service
from app.schemas.twilio_call import TwilioCallCreate, TwilioCallResponse, TwilioCallStatus
from app.crud.contact import get_contact, add_dialog, add_dialog_message

# –ù–æ–≤—ã–π API
from google import genai
from google.genai import types

from dotenv import load_dotenv
load_dotenv()

# import openai  # –∏–ª–∏ —Ç–≤–æ–π –∫–ª–∏–µ–Ω—Ç genai_model
# genai_model = openai  # –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ




client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))

BASE_URL = os.getenv("BASE_URL")
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

START_WAV_PATH = os.path.join(BASE_DIR, 'sounds',"start.wav")
END_WAV_PATH = os.path.join(BASE_DIR, 'sounds', "end.wav")

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/twilio-calls", tags=["twilio_calls"])

# –•—Ä–∞–Ω–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤ –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
active_calls: Dict[str, Dict] = {}  # call_sid -> {contact_id, user_id, script}
active_connections: Dict[str, WebSocket] = {}  # call_sid -> websocket

connected_clients = []  # —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∫–ª–∏–µ–Ω—Ç—ã


@router.post("/initiate", response_model=TwilioCallResponse)
def initiate_call(
    call_data: TwilioCallCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(deps.get_current_active_user)
):
    """
    –ò–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç –∑–≤–æ–Ω–æ–∫ —á–µ—Ä–µ–∑ Twilio (—Ä–µ–∞–ª—å–Ω—ã–π –∑–≤–æ–Ω–æ–∫)
    """
    logger.info(f"üìû Initiating REAL call for user {current_user.id}, contact {call_data.contact_id}")
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç
    contact = get_contact(db, contact_id=call_data.contact_id, user_id=current_user.id)
    if not contact:
        logger.warning(f"‚ùå Contact {call_data.contact_id} not found for user {current_user.id}")
        raise HTTPException(status_code=404, detail="Contact not found")
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫—Ä–∏–ø—Ç –∏–∑ –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏–∑ –∫–æ–Ω—Ç–∞–∫—Ç–∞
    script = call_data.script or contact.script
    if not script:
        logger.warning(f"‚ùå No script provided for contact {contact.id}")
        raise HTTPException(status_code=400, detail="No script provided")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ Twilio –∫–ª–∏–µ–Ω—Ç–∞
    if not twilio_service.client:
        logger.error("‚ùå Twilio service not initialized")
        raise HTTPException(status_code=500, detail="Twilio service not configured")
    
    # –°–æ–≤–µ—Ä—à–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∑–≤–æ–Ω–æ–∫ —á–µ—Ä–µ–∑ Twilio
    call_sid = twilio_service.make_call(
        to_number=contact.phone,
        script=script,
        contact_id=contact.id
    )
    
    if not call_sid:
        logger.error(f"‚ùå Failed to initiate REAL call to {contact.phone}")
        raise HTTPException(status_code=500, detail="Failed to initiate call")
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∏–∞–ª–æ–≥ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    try:
        messages = [
            {
                "role": "agent",
                "text": script
            }
        ]
        
        dialog = add_dialog(
            db=db,
            contact_id=contact.id,
            user_id=current_user.id,
            messages=messages,
            transcript=script
        )
        
        if dialog:
            logger.info(f"‚úÖ Dialog saved to database. ID: {dialog.id}")
        else:
            logger.error("‚ùå Failed to save dialog to database")
            
    except Exception as e:
        logger.error(f"‚ùå Error saving dialog: {e}")
    
    logger.info(f"‚úÖ REAL call initiated successfully. SID: {call_sid}")
    
    return TwilioCallResponse(
        call_sid=call_sid,
        status="initiated",
        message="Real call initiated successfully"
    )

@router.get("/{call_sid}/status", response_model=TwilioCallStatus)
def get_call_status(
    call_sid: str,
    current_user: User = Depends(deps.get_current_active_user)
):
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∑–≤–æ–Ω–∫–∞ –∏–∑ Twilio
    """
    logger.info(f"üìû Getting REAL call status for {call_sid}")
    
    # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–≤–æ–Ω–∫–∞ –∏–∑ Twilio
    call_status = twilio_service.get_call_status(call_sid)
    
    if not call_status:
        logger.error(f"‚ùå Failed to get call status for {call_sid}")
        raise HTTPException(status_code=500, detail="Failed to get call status")
    
    logger.info(f"‚úÖ Call status retrieved: {call_status['status']}")
    
    return TwilioCallStatus(
        call_sid=call_status['call_sid'],
        status=call_status['status'],
        duration=call_status['duration'],
        recording_url=None  # –ü–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ
    )

@router.post("/webhook")
async def twilio_webhook(request: Request):
    """
    Webhook –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π –æ—Ç Twilio
    """
    try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–æ—Ä–º—ã
        form_data = await request.form()
        
        # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ
        logger.info(f"üì± Twilio webhook received: {dict(form_data)}")
        
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π
        # –ù–∞–ø—Ä–∏–º–µ—Ä, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–≤–æ–Ω–∫–∞ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        
        return Response(status_code=200)
        
    except Exception as e:
        logger.error(f"‚ùå Error processing Twilio webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/status")
async def call_status_webhook(request: Request, db: Session = Depends(get_db)):
    """
    Webhook –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–≤–æ–Ω–∫–∞
    """
    try:
        form_data = await request.form()
        call_sid = form_data.get('CallSid')
        call_status = form_data.get('CallStatus')
        
        logger.info(f"üìû Call {call_sid} status: {call_status}")
        
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–≤–æ–Ω–∫–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        
        return Response(status_code=200)
        
    except Exception as e:
        logger.error(f"‚ùå Error processing call status: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    


@router.websocket("/ws/dialog")
async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocket –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–µ–∫—Å—Ç–∞ –¥–∏–∞–ª–æ–≥–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥.
    –°–µ—Ä–≤–µ—Ä –±—É–¥–µ—Ç –ø—É—à–∏—Ç—å —Ç—É–¥–∞ —Ä–∞—Å–ø–æ–∑–∞–Ω–Ω—É—é —Ä–µ—á—å –∞–±–æ–Ω–µ–Ω—Ç–∞ –∏ —Å—Ç–∞—Ç—É—Å—ã –∑–≤–æ–Ω–∫–∞.
    """
    await websocket.accept()
    connected_clients.append(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # –ú–æ–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã –æ—Ç —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "start call"
            logger.info(f"Received from frontend: {data}")
    except Exception as e:
        connected_clients.remove(websocket)
        logger.info(f"Frontend disconnected: {e}")

async def broadcast_message(message: str):
    """
    –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ –≤—Å–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–º —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥-–∫–ª–∏–µ–Ω—Ç–∞–º.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –≤ UI –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–∏–∞–ª–æ–≥–∞.
    """
    for client in connected_clients[:]:  # –ö–æ–ø–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
        try:
            await client.send_text(message)
        except Exception as e:
            logger.error(f"Failed to send message to client: {e}")
            if client in connected_clients:
                connected_clients.remove(client)




@router.post("/initiate-dialog", response_model=TwilioCallResponse)
def initiate_dialog_call(
    call_data: TwilioCallCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(deps.get_current_active_user)
):
    contact = get_contact(db, contact_id=call_data.contact_id, user_id=current_user.id)
    if not contact:
        raise HTTPException(status_code=404, detail="Contact not found")

    script = call_data.script or contact.script
    if not script:
        raise HTTPException(status_code=400, detail="No script provided")

    if not twilio_service.client:
        raise HTTPException(status_code=500, detail="Twilio service not configured")

    # URL –≤–µ–±—Ö—É–∫–∞ –¥–ª—è –∑–≤–æ–Ω–∫–∞
    script_encoded = quote(script)
    webhook_url = f"{call_data.base_url}/api/twilio-calls/dialog/answer?script={script_encoded}&contact_id={contact.id}&user_id={current_user.id}"

    call_sid = twilio_service.make_call_with_url(
        to_number=contact.phone,
        url=webhook_url,
        contact_id=contact.id
    )

    if not call_sid:
        raise HTTPException(status_code=500, detail="Failed to initiate call")

    active_calls[call_sid] = {
        "contact_id": contact.id,
        "user_id": current_user.id,
        "script": script
    }

    return TwilioCallResponse(
        call_sid=call_sid,
        status="initiated",
        message="Dialog call initiated successfully"
    )


# --------------------- –î–∏–∞–ª–æ–≥–æ–≤—ã–µ Webhook ---------------------

@router.post("/dialog/answer")
async def dialog_answer(request: Request, script: str = None, contact_id: int = None, user_id: int = None):

    resp = VoiceResponse()

    # –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –≥–æ—Ç–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å start.wav
    start_wav_url = f"{os.getenv('BASE_URL')}/static/start.wav"
    print(start_wav_url, 'from funcion dialog_answer')
    resp.play(start_wav_url)

    gather = Gather(
        input="speech",
        action=f"/api/twilio-calls/dialog/gather?script={quote(script or '')}&contact_id={contact_id}&user_id={user_id}",
        speech_timeout=1.5,
        language="sk-SK"
    )
    resp.append(gather)

    resp.hangup()
    return Response(content=str(resp), media_type="application/xml")



# ==============================
# Dialog Gather Webhook (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –∞–±–æ–Ω–µ–Ω—Ç–∞)

@router.post("/dialog/gather")
async def dialog_gather(
    request: Request,
    script: str = None,
    contact_id: int = None,
    user_id: int = None,
    db: Session = Depends(get_db)
):
    from twilio.twiml.voice_response import VoiceResponse

    form = await request.form()
    speech_result = form.get("SpeechResult")
    call_sid = form.get("CallSid")

    resp = VoiceResponse()
    script_decoded = unquote(script) if script else ""

    if not speech_result:
        # –ï—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –º–æ–ª—á–∏—Ç ‚Üí –∑–∞–≤–µ—Ä—à–∞–µ–º
        end_wav_url = f"{os.getenv('BASE_URL')}/static/end.wav"
        resp.play(end_wav_url)
        resp.hangup()
        return Response(content=str(resp), media_type="application/xml")

    # --------------------------
    # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–ø–ª–∏–∫—É –∫–ª–∏–µ–Ω—Ç–∞
    # --------------------------

    normalized = speech_result.lower().strip()
    logger.info(f"üéß Speech result: {normalized}")
    await save_speech_message(db, call_sid, "client", normalized)

    # --------------------------
    # 2. –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
    # --------------------------

    classification = await classify_user_response(normalized)

    # --------------------------
    # 3. –í–µ—Ç–≤–ª–µ–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è
    # --------------------------

    if classification == "exit":
        end_wav_url = f"{os.getenv('BASE_URL')}/static/end.wav"
        resp.play(end_wav_url)
        resp.hangup()

    elif classification == "question":
        reply = await generate_ai_reply(normalized)
        await save_speech_message(db, call_sid, "agent", reply)

        # –û–∑–≤—É—á–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç
        tts_url = f"{os.getenv('BASE_URL')}/api/twilio-calls/gemini-tts-live?text={quote(reply)}"
        resp.play(tts_url)

        gather = Gather(
            input="speech",
            action=f"{os.getenv('BASE_URL')}/api/twilio-calls/dialog/gather?script={quote(script_decoded)}&contact_id={contact_id}&user_id={user_id}",
            speech_timeout=1.5,
            language="sk-SK"
        )

        # –°–Ω–æ–≤–∞ –∑–∞–¥–∞—ë–º —É—Ç–æ—á–Ω—è—é—â–∏–π –≤–æ–ø—Ä–æ—Å
        squestion_wav_url = f"{os.getenv('BASE_URL')}/static/squestion.wav"
        gather.play(squestion_wav_url)

        resp.append(gather)
        resp.hangup()

    elif classification == "positive":
        # –ß–∏—Ç–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç
        tts_url = f"{os.getenv('BASE_URL')}/api/twilio-calls/gemini-tts-live?text={quote(script_decoded)}"
        resp.play(tts_url)

        # –°–ø—Ä–æ—Å–∏–º –ø—Ä–æ –≤–æ–ø—Ä–æ—Å—ã –∏ —Å—Ä–∞–∑—É —Å–æ–∑–¥–∞—ë–º Gather
        gather = Gather(
            input="speech",
            action=f"{os.getenv('BASE_URL')}/api/twilio-calls/dialog/gather?script={quote(script_decoded)}&contact_id={contact_id}&user_id={user_id}",
            speech_timeout=1.5,
            language="sk-SK"
        )

        # –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º —Ñ—Ä–∞–∑—É –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤
        fquestion_wav_url = f"{os.getenv('BASE_URL')}/static/fquestion.wav"
        gather.play(fquestion_wav_url)

        resp.append(gather)
        resp.hangup()

    else:  # neutral
        # –ï—Å–ª–∏ –Ω–µ–ø–æ–Ω—è—Ç–Ω–æ ‚Üí —É—Ç–æ—á–Ω—è–µ–º
        gather = Gather(
            input="speech",
            action=f"{os.getenv('BASE_URL')}/api/twilio-calls/dialog/gather?script={quote(script_decoded)}&contact_id={contact_id}&user_id={user_id}",
            speech_timeout=1.5,
            language="sk-SK"
        )

        # –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—É—é —Ñ—Ä–∞–∑—É
        repeat_wav_url = f"{os.getenv('BASE_URL')}/static/repeat.wav"
        gather.play(repeat_wav_url)

        resp.append(gather)
        resp.hangup()

    return Response(content=str(resp), media_type="application/xml")



# ==============================
# Gemini TTS Endpoint (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç mp3 base64)

@router.get("/gemini-tts")
async def gemini_tts(text: str):
    audio_bytes = await process_text_to_speech(text)
    audio_base64 = base64.b64encode(audio_bytes).decode("utf-8")
    return JSONResponse({"audio": audio_base64, "text": text, "duration": len(text) * 0.1})


# ==============================
# Media Stream WebSocket (—Ä–µ–∞–ª—å–Ω—ã–π TTS/STT)
@router.websocket("/media-stream/{call_sid}")
async def media_stream_websocket(websocket: WebSocket, call_sid: str, db: Session = Depends(get_db)):
    await websocket.accept()
    logger.info(f"üéôÔ∏è Media stream connected for call {call_sid}")

    if call_sid not in active_calls:
        await websocket.close(code=1008, reason="Call not found")
        return

    call_info = active_calls[call_sid]

    try:
        while True:
            data = await websocket.receive_text()
            msg = json.loads(data)

            if msg.get("event") == "media":
                recognized_text = await process_speech_to_text(msg)
                if recognized_text:
                    await save_speech_message(db, call_sid, "client", recognized_text)
                    response_text = f"ƒéakujem. Teraz v√°m preƒç√≠tam spr√°vu: {call_info['script']}"
                    audio_bytes = await process_text_to_speech(response_text)
                    await websocket.send_text(json.dumps({
                        "event": "media",
                        "audio": base64.b64encode(audio_bytes).decode("utf-8")
                    }))
    except Exception as e:
        logger.error(f"‚ùå WebSocket error: {e}")
    finally:
        await websocket.close()
        logger.info(f"‚ùå WebSocket closed for call {call_sid}")


# --------------------- Gemini TTS/STT ---------------------
async def process_speech_to_text(audio_bytes: bytes) -> str:
    """
    STT —á–µ—Ä–µ–∑ Gemini
    """
    try:
        response = client.models.generate_content(
            model="gemini-1.5-pro",
            contents=[{
                "role": "user",
                "parts": [types.Part(
                    inline_data=types.Blob(
                        mime_type="audio/wav",
                        data=audio_bytes
                    )
                )]
            }],
            config=types.GenerateContentConfig(
                response_modalities=["TEXT"]
            )
        )

        return response.candidates[0].content.parts[0].text.strip()
    except Exception as e:
        logger.error(f"‚ùå STT error: {e}")
        return ""

# ---------------------------
# TTS (Text-to-Speech)
# ---------------------------
async def process_text_to_speech(text: str) -> bytes:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ—á–∏ —á–µ—Ä–µ–∑ Gemini 2.5 Flash Preview TTS (—Å–ª–æ–≤–∞—Ü–∫–∏–π —è–∑—ã–∫)
    """
    try:
        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
        text_decoded = unquote(text)
        logger.info(f"üîä Generating TTS for text: {text_decoded[:50]}...")

        response = client.models.generate_content(
            model="gemini-2.5-flash-preview-tts",
            contents=text_decoded,
            config=types.GenerateContentConfig(
                response_modalities=["AUDIO"],
                speech_config=types.SpeechConfig(
                    voice_config=types.VoiceConfig(
                        prebuilt_voice_config=types.PrebuiltVoiceConfig(
                            voice_name="Kore"  # –ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –≥–æ–ª–æ—Å –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
                        )
                    )
                )
            )
        )

        # –ü–æ–ª—É—á–∞–µ–º –∞—É–¥–∏–æ-–¥–∞–Ω–Ω—ã–µ –∏–∑ –æ—Ç–≤–µ—Ç–∞
        audio_bytes = response.candidates[0].content.parts[0].inline_data.data
        if not audio_bytes:
            raise ValueError("Gemini TTS –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç")

        return audio_bytes

    except Exception as e:
        logger.error(f"‚ùå Gemini TTS error: {e}")
        return b""



# --------------------- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π ---------------------

async def save_speech_message(db: Session, call_sid: str, role: str, text: str):
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—Å—Ç –≤ –ë–î
    """
    call_info = active_calls.get(call_sid)
    if not call_info:
        logger.warning(f"‚ùå Call {call_sid} not found")
        return

    dialog = db.query(ContactDialog).filter(
        ContactDialog.contact_id == call_info["contact_id"],
    ).order_by(ContactDialog.date.desc()).first()

    if not dialog:
        dialog = ContactDialog(
            contact_id=call_info["contact_id"],
            user_id=call_info["user_id"],
            date=datetime.utcnow()
        )
        db.add(dialog)
        db.commit()
        db.refresh(dialog)

    message = DialogMessage(
        dialog_id=dialog.id,
        role=role,
        text=text
    )
    db.add(message)
    db.commit()
    db.refresh(message)
    logger.info(f"üíæ Saved {role} message: {text[:50]}...")


# --------------------- Gemini TTS endpoint ---------------------

def pcm_to_wav(pcm_bytes: bytes, sample_rate=24000, channels=1, sample_width=2):
    buf = io.BytesIO()
    with wave.open(buf, "wb") as wf:
        wf.setnchannels(channels)
        wf.setsampwidth(sample_width)
        wf.setframerate(sample_rate)
        wf.writeframes(pcm_bytes)
    buf.seek(0)
    return buf


@router.get("/gemini-tts-live")
async def gemini_tts_live(text: str = Query(..., description="–¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è")):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç WAV –ø–æ—Ç–æ–∫ –¥–ª—è Twilio Play.
    Twilio –æ–∂–∏–¥–∞–µ—Ç –ø—Ä—è–º–æ–π WAV URL.
    """
    try:
        # –ü–æ–ª—É—á–∞–µ–º "—Å—ã—Ä–æ–µ" –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ –æ–±—â—É—é —Ñ—É–Ω–∫—Ü–∏—é
        audio_bytes = await process_text_to_speech(text)
        if not audio_bytes:
            raise HTTPException(status_code=500, detail="TTS –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–µ –∞—É–¥–∏–æ")

        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º PCM –≤ WAV –¥–ª—è Twilio
        wav_io = pcm_to_wav(audio_bytes)

        return StreamingResponse(wav_io, media_type="audio/wav")

    except Exception as e:
        logger.error(f"‚ùå gemini_tts_live error: {e}")
        raise HTTPException(status_code=500, detail=f"TTS error: {e}")

    


def is_positive_response(speech: str) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≥–ª–∞—Å–∏—è (–¥–∞/–Ω–µ—Ç)
    """

    if not speech:
        return False

    text = speech.strip().lower()

    positive_keywords = [
        "√°no", "ano", "jo", "ok", "okay", "yes", "da", "sure", "jasn√©", "hej"
    ]

    return any(word in text for word in positive_keywords)


async def generate_ai_reply(user_text: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –∞–≥–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ Gemini.
    user_text: —á—Ç–æ —Å–∫–∞–∑–∞–ª –∫–ª–∏–µ–Ω—Ç
    contact_id, user_id: –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏
    """
    try:
        prompt = f"""
            Si zdvoril√Ω a u≈æitoƒçn√Ω asistent predaja.
        Klient povedal: ‚Äû{user_text}‚Äú.
        Odpovedz na slov√° klienta v slovenƒçine, struƒçne a priateƒæsky.
        Ak ot√°zka nie je k veci, jemne vr√°≈• rozhovor sp√§≈• k produktu.
        """

        response = client.models.generate_content(
            model="gemini-1.5-flash",
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=["TEXT"],
                temperature=0.6,
            )
        )

        ai_reply = response.candidates[0].content.parts[0].text.strip()
        logger.info(f"ü§ñ Agent reply: {ai_reply}")
        return ai_reply

    except Exception as e:
        logger.error(f"‚ùå Gemini reply error: {e}")
        return "Prep√°ƒçte, nerozumel som ot√°zke."

async def classify_user_response(text: str) -> str:
    """
    –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: positive / exit / question / neutral
    """
    prompt = f"""
        Si asistent, ktor√Ω analyzuje reƒç pou≈æ√≠vateƒæa v slovenskom jazyku.
        Text: ‚Äû{text}‚Äú

        Tvoja √∫loha: urƒçi≈• jednu z tried:
        - ‚Äûpositive‚Äú ‚Üí s√∫hlas/povolenie pokraƒçova≈•
        - ‚Äûexit‚Äú ‚Üí rozl√∫ƒçka, ukonƒçenie rozhovoru
            - ‚Äûquestion‚Äú ‚Üí dopl≈àuj√∫ca ot√°zka alebo ≈æiados≈• o dodatoƒçn√© inform√°cie
        - ‚Äûneutral‚Äú ‚Üí in√©

        Odpovedzte len jedn√Ωm slovom zo zoznamu: positive, exit, question, neutral.
    """

    response = client.models.generate_content(
        model="gemini-2.0-flash",  # –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –ª—é–±–æ–π –ª—ë–≥–∫–∏–π —á–∞—Ç-–º–æ–¥–µ–ª—å
        contents=prompt
    )

    classification = response.candidates[0].content.parts[0].text.strip().lower()
    return classification
